<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="The URL loading system provides support for accessing resources using the following protocols:

File Transfer Protocol (ftp://)
Hypertext Transfer Protocol(http://)
Hypertext Transfer Protocol with en">
<meta property="og:type" content="article">
<meta property="og:title" content="URL Session 编程指南">
<meta property="og:url" content="http://yoursite.com/2016/09/24/URL-Session-编程指南/index.html">
<meta property="og:site_name" content="云天外">
<meta property="og:description" content="The URL loading system provides support for accessing resources using the following protocols:

File Transfer Protocol (ftp://)
Hypertext Transfer Protocol(http://)
Hypertext Transfer Protocol with en">
<meta property="og:image" content="http://yoursite.com/Users/hl/Desktop/iOS 学习笔记/URL Loading System.png">
<meta property="og:updated_time" content="2016-12-13T07:45:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="URL Session 编程指南">
<meta name="twitter:description" content="The URL loading system provides support for accessing resources using the following protocols:

File Transfer Protocol (ftp://)
Hypertext Transfer Protocol(http://)
Hypertext Transfer Protocol with en">
<meta name="twitter:image" content="http://yoursite.com/Users/hl/Desktop/iOS 学习笔记/URL Loading System.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/09/24/URL-Session-编程指南/"/>





  <title> URL Session 编程指南 | 云天外 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">云天外</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">The best preparation for tomorrow is doing your best today.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/24/URL-Session-编程指南/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="云天外">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="云天外" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                URL Session 编程指南
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-24T19:23:04+08:00">
                2016-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>The URL loading system provides support for accessing resources using the following protocols:</p>
<ul>
<li>File Transfer Protocol (<code>ftp://</code>)</li>
<li>Hypertext Transfer Protocol(<code>http://</code>)</li>
<li>Hypertext Transfer Protocol with encryption (<code>https://</code>)</li>
<li>Local file URLs (<code>file:///</code>)</li>
<li>Data URLs (<code>data://</code>)</li>
</ul>
<p>It also transparently supports both proxy servers and SOCKS gateways using the user’s system preferences.</p>
<p><img src="/Users/hl/Desktop/iOS 学习笔记/URL Loading System.png" alt="glance"></p>
<p><strong>Fetching Content as Data (In Memory) / Downloading Content as a File</strong></p>
<p>At a high level, there are two basic approaches to fetching URL data:</p>
<ul>
<li>For simple requests, use the <code>NSURLSession</code> API to retrieve the contents from an <code>NSURL</code> object directly, either as an <code>NSData</code> object or as a file on disk.</li>
<li>For more complex requests—requests that upload data, for example—provide an <code>NSURLRequest</code> object (or its mutable subclass, <code>NSMutableURLRequest</code>) to <code>NSURLSession</code>.</li>
</ul>
<p>Regardless of which approach you choose, your app can obtain the response data in two ways:</p>
<ul>
<li>Provide a completion handler block. The URL loading class calls that block when it finishes receiving data from the server.</li>
<li>Provide a custom delegate. The URL loading class periodically calls your delegate methods as it receives the data from the originating source. Your app is responsible for accumulating that data, if needed.</li>
</ul>
<p>In addition to the data itself, the URL loading class provides your delegate or completion handler block with a response object that encapsulates metadata associated with the request, such as the MIME type and content length.</p>
<p><strong>NSURLRequest</strong></p>
<p>An <code>NSURLRequest</code> object encapsulates a URL and any protocol-specific（协议特定的) properties, in a protocol-independent manner.</p>
<p><strong>注意：</strong>When a client app initiates a connection or download using an instance of <code>NSMutableURLRequest</code>, a <strong>deep copy</strong> is made of the request. Changes made to the initiating request have no effect after a download is initialized.</p>
<p><strong>NSURLResponse</strong></p>
<p>The response from a server to a request can be viewed as two parts: metadata describing the contents and the content data itself. Metadata that is common to most protocols is encapsulated by the <code>NSURLResponse</code> class and consists of the MIME type, expected content length, text encoding (where applicable), and the URL that provided the response. Protocol-specific subclasses of <code>NSURLResponse</code> can provide additional metadata. For example, <code>NSHTTPURLResponse</code> stores the headers and the status code returned by the web server.</p>
<p><strong>注意：</strong>Only the metadata for the response is stored in an <code>NSURLResponse</code> object. The various URL loading classes provide the response data itself to your app either through a completion handler block or to the object’s delegate.</p>
<p><strong>NSCachedURLResponse</strong></p>
<p>An <code>NSCachedURLResponse</code> instance encapsulates an <code>NSURLResponse</code> object, the URL content data, and any additional information provided by your app. </p>
<p><strong>Note:</strong> Credentials stored in persistent storage are kept in the user’s keychain and shared among all apps.</p>
<p><strong>NSURLCredential</strong></p>
<p>The <code>NSURLCredential</code> class encapsulates a credential consisting of authentication information (user name and password, for example) and persistence behavior. The <code>NSURLProtectionSpace</code> class represents an area that requires a specific credential. A protection space can be limited to a single URL, encompass a realm on a web server, or refer to a proxy.</p>
<p>A shared instance of the <code>NSURLCredentialStorage</code> class manages credential storage and provides the mapping of an <code>NSURLCredential</code> object to the corresponding <code>NSURLProtectionSpace</code> object for which it provides authentication.</p>
<p>The <code>NSURLAuthenticationChallenge</code> class encapsulates the information required by an <code>NSURLProtocol</code> implementation to authenticate a request: a proposed credential, the protection space involved, the error or response that the protocol used to determine that authentication is required, and the number of authentication attempts that have been made. An <code>NSURLAuthenticationChallenge</code> instance also specifies the object that initiated the authentication. The initiating object, referred to as the sender, must conform to the <code>NSURLAuthenticationChallengeSender</code> protocol.</p>
<p><code>NSURLAuthenticationChallenge</code> instances are used by <code>NSURLProtocol</code> subclasses to inform the URL loading system that authentication is required. They are also provided to the delegate methods of <code>NSURLSession</code> that facilitate customized authentication handling.</p>
<p><strong>NSURLCache</strong></p>
<p> The cache is queried by <code>NSURLSession</code> according to the cache policy specified by the initiating <code>NSURLRequest</code> and <code>NSURLSessionConfiguration</code> objects.</p>
<p> The <code>NSURLCache</code> class provides methods to configure the cache size and its location on disk. It also provides methods to manage the collection of <code>NSCachedURLResponse</code> objects that contain the cached responses.</p>
<p>An <code>NSCachedURLResponse</code> object encapsulates the <code>NSURLResponse</code> object and the URL content data. <code>NSCachedURLResponse</code> also provides a user info dictionary that your app can use to cache any custom data.</p>
<p><em>Not all protocol implementations support response caching. Currently only http and https requests are cached.</em></p>
<p>An <code>NSURLSession</code> object can control whether a response is cached and whether the response should be cached only in memory by implementing the <code>URLSession:dataTask:willCacheResponse:completionHandler:</code> delegate method.</p>
<p><strong>NSHTTPCookie</strong></p>
<p>OS X and iOS provide the <code>NSHTTPCookieStorage</code> class, which in turn provides the interface for managing a collection of <code>NSHTTPCookie</code> objects. In OS X, cookie storage is shared across all apps; in iOS, cookie storage is per-app.</p>
<p>The URL loading system natively supports the <code>http</code>, <code>https</code>, <code>file</code>, <code>ftp</code>, and <code>data</code> protocols. However, the URL loading system also allows your app to register your own classes to support additional application-layer networking protocols. You can also add protocol-specific properties to URL request and URL response objects.</p>
<p><strong>NSURLSession</strong></p>
<p>它提供了通过HTTP下载内容的API，以及丰富的代理方法来支持认证和APP后台下载的能力等。一个session可以管理一系列的任务，每一个任务代表一个特定的URL(以及衍生出来的URL请求，当原始的URL返回HTTP重定向)请求。</p>
<p>其API高度异步处理，当使用默认的，系统提供的代理时，必须提供block回调。如果自定义代理对象，则会调用那些代理方法。注意：回调block对于自定义代理对象是可选的，如果创建任务时使用的方法含有completion callback则代理方法不会被调用。</p>
<p>它的API提供状态，进度等属性，以及将这些信息分发给代理。还支持取消，重新开始任务，挂起，还支持在挂起，取消，失败的位置重新开始任务（断点续传）.</p>
<p><strong>理解URL session的概念</strong></p>
<p>一个session之中的任务的行为取决于三个方面：</p>
<ul>
<li>session的类型(由创建session所使用的configuration对象的类型决定)</li>
<li>任务类型</li>
<li>当任务被创建时APP是否是在foreground</li>
</ul>
<p><strong>session类型</strong></p>
<p>支持三种类型：</p>
<ul>
<li><em>Default sessions</em> ：行为与其他Foundation中用于URLs下载的方法相似。They use a persistent disk-based cache and store credentials in the user’s keychain.</li>
<li><em>Ephemeral（短暂的） sessions</em> ：不会存储任何数据到磁盘；所有的缓存，证书存储等等被保存在RAM，并与session绑定。因此，当APP废弃了session，所有的数据将全部清理。</li>
<li><em>Background sessions</em> :与默认session相似，除了他使用一个单独的process处理所有的数据传输。它有一些额外的限制，见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW44" target="_blank" rel="external">Background Transfer Considerations</a></li>
</ul>
<p><strong>任务类型</strong></p>
<ul>
<li><em>Data tasks</em> :使用<code>NSData</code>对象发送和接收数据。Data tasks are intended for short, often interactive requests from your app to a server. Data tasks can return data to your app one piece at a time after each piece of data is received, or all at once through a completion handler.</li>
<li><em>Download tasks</em>  ：retrieve data in the form of a file, and support background downloads while the app is not running.</li>
<li><em>Upload tasks</em> ：send data in the form of a file, and support background uploads while the app is not running.</li>
</ul>
<p><strong>有关后台传输的考虑(background transfer considerations)</strong></p>
<p>当APP处于挂起状态时，<code>NSURLSession</code>支持后台传输。只有使用background session configuration 对象创建的session才支持background transfers (即通过调用方法<code>backgroundSessionConfiguration:</code>方法得到的session)。</p>
<p>With background sessions, because the actual transfer is performed by a separate process and because restarting your app’s process is relatively expensive, a few features are unavailable, resulting in the following limitations:</p>
<ul>
<li><strong>The session must provide a delegate for event delivery. (For uploads and downloads, the delegates behave the same as for in-process transfers.)</strong></li>
<li><strong>Only HTTP and HTTPS protocols are supported (no custom protocols).</strong></li>
<li><strong>Redirects are always followed.</strong></li>
<li><strong>Only upload tasks from a file are supported (uploading from data objects or a stream will fail after the program exits).</strong></li>
<li><strong>If the background transfer is initiated while the app is in the background, the configuration object’s <code>discretionary</code> property is treated as being <code>true</code>.</strong></li>
</ul>
<p><strong>注意：</strong>在iOS 8 和 OS X 10.10之前，data tasks是不支持background session的。</p>
<p>In iOS, when a background transfer completes or requires credentials, if your app is no longer running, iOS automatically relaunches your app in the background and calls the <code>application:handleEventsForBackgroundURLSession:completionHandler:</code> method on your app’s <code>UIApplicationDelegate</code> object. This call provides the identifier of the session that caused your app to be launched. Your app should store that completion handler, create a background configuration object with the same identifier, and create a session with that configuration object. The new session is automatically reassociated with ongoing background activity. Later, when the session finishes the last background download task, it sends the session delegate a <code>URLSessionDidFinishEventsForBackgroundURLSession:</code>message. In that delegate method, call the previously stored completion handler on the main thread so that the operating system knows that it is safe to suspend your app again.</p>
<p>In both iOS and OS X, when the user relaunches your app, your app should immediately create background configuration objects with the same identifiers as any sessions that had outstanding tasks when your app was last running, then create a session for each of those configuration objects. These new sessions are similarly automatically reassociated with ongoing background activity.</p>
<p><strong>注意：</strong>必须准确的一个identifier对应一个session(identifier是在创建configuration对象时指定的)。多个session共享一个identifier，其行为具有不确定性。</p>
<p>If any task completed while your app was suspended, the delegate’s <code>URLSession:downloadTask:didFinishDownloadingToURL:</code>method is then called with the task and the URL for the newly downloaded file associated with it.</p>
<p>Similarly, if any task requires credentials, the <code>NSURLSession</code> object calls the delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code> method or <code>URLSession:didReceiveChallenge:completionHandler:</code> method as appropriate。</p>
<p><strong>Upload and download tasks in background sessions are automatically retried</strong> by the URL loading system after network errors. It is unnecessary to use reachability APIs to determine when to retry a failed task.</p>
<p><strong>生命周期和代理交互(Life Cycle and Delegate Interaction)</strong></p>
<p>见下文中的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW1" target="_blank" rel="external">Life Cycle of a URL Session</a></p>
<p>session 和 task对象遵循<code>NSCopying</code>协议：</p>
<ul>
<li>当你的APP copy了一个session 或者 task 对象，你会获得同一个对象(即浅拷贝，没有产生一份新的拷贝)</li>
<li>当你的APP copy一个configuration 对象，你会获得一份新的拷贝(即深拷贝)，你可以对这份拷贝独立地进行调整</li>
</ul>
<p><strong>代理类的interface代码示例</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^CompletionHandler)();</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySessionDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDelegate</span>, <span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>, <span class="title">NSURLSessionStreamDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSMutableDictionary</span> &lt;<span class="built_in">NSString</span> *, CompletionHandler&gt;*completionHandlers;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></div></pre></td></tr></table></figure>
<p><strong>创建和配置session</strong></p>
<ul>
<li>Private storage support for caches, cookies, credentials, and protocols in a way that is specific to a single session</li>
<li>Authentication, tied to a specific request (task) or group of requests (session)</li>
<li>File uploads and downloads by URL, which encourages separation of the data (the file’s contents) from the metadata (the URL and settings)</li>
<li>Configuration of the maximum number of connections per host</li>
<li>Per-resource timeouts that are triggered if an entire resource cannot be downloaded in a certain amount of time</li>
<li>Minimum and maximum TLS version support</li>
<li>Custom proxy dictionaries</li>
<li>Control over cookie policies</li>
<li>Control over cookie policies</li>
</ul>
<p>因为大部分的设置包含在一个单独的configuration对象中，因此通常你可以重用那些设置。当你实例化一个session对象时，你要指定以下：</p>
<ul>
<li>A configuration object that governs the behavior of that session and the tasks within it</li>
<li>Optionally, a delegate object to process incoming data as it is received and handle other events specific to the session and the tasks within it, such as server authentication, determining whether a resource load request should be converted into a download, and so on</li>
</ul>
<p>如果不提供代理，<code>NSURLSession</code>对象使用系统提供的代理。如果这样的话，你可以使用<code>NSURLSession</code>的更方便的方法—-<code>sendAsynchronousRequest:queue:completionHandler:</code><br><strong>注意：</strong>如果想要进行后台数据传输，必须提供自定义的代理</p>
<p>在实例化session对象后，你不能再改变configuration对象和delegate。</p>
<p>创建和配置session示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Creating session configurations</span></div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *defaultConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *ephemeralConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *backgroundConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> backgroundSessionConfigurationWithIdentifier: <span class="string">@"com.myapp.networking.background"</span>];</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">// Configuring caching behavior for the default session</span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *cachesDirectory = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *cachePath = [cachesDirectory stringByAppendingPathComponent:<span class="string">@"MyCache"</span>];</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/* Note:</span></div><div class="line"></div><div class="line"> iOS requires the cache path to be</div><div class="line"></div><div class="line"> a path relative to the ~/Library/Caches directory,</div><div class="line"></div><div class="line"> but OS X expects an absolute path.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#if TARGET_OS_OSX</span></div><div class="line"></div><div class="line">cachePath = [cachePath stringByStandardizingPath];</div><div class="line"></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="built_in">NSURLCache</span> *cache = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">16384</span> diskCapacity:<span class="number">268435456</span> diskPath:cachePath];</div><div class="line"></div><div class="line">defaultConfiguration.URLCache = cache;</div><div class="line"></div><div class="line">defaultConfiguration.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">// Creating sessions</span></div><div class="line"></div><div class="line"><span class="keyword">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt; delegate = [[MySessionDelegate alloc] init];</div><div class="line"></div><div class="line"><span class="built_in">NSOperationQueue</span> *operationQueue = [<span class="built_in">NSOperationQueue</span> mainQueue];</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="built_in">NSURLSession</span> *defaultSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultConfiguration delegate:delegate operationQueue:operationQueue];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSession</span> *ephemeralSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSession</span> *backgroundSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:backgroundConfiguration delegate:delegate delegateQueue:operationQueue];</div></pre></td></tr></table></figure>
<p>除了background configuration之外，你可以复用session configuration 对象来创建其它的session。(不能复用background configuration是因为，两个background session共用一个identifier，session的行为将不确定)。</p>
<p>安全的调整configuration 对象：当创建了一个session，session会深拷贝这个configuration对象，因此对configuration的调整只会影响这个新创建的session，不会影响已存在的session。例如，可以创建另一个session，该session只有在Wi-Fi连接条件下才可以检索内容。代码如下(代码中使用的ephemeralConfiguration还是上文创建的那个，因为第一个使用该configuration的session对它进行了深拷贝，所以在这里改变该configuration不会影响之前使用该configuration的session)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ephemeralConfiguration.allowsCellularAccess = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSURLSession</span> *ephemeralSessionWiFiOnly = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</div></pre></td></tr></table></figure>
<p><strong>通过系统提供的代理获取数据(Fetching Resources Using System-Provided Delegates)</strong></p>
<p>使用系统提供的代理，你只需要提供两方面的代码就可以了：</p>
<ul>
<li>创建configuration对象，和一个基于该对象的session</li>
<li>一个completion handler的处理，即接收完数据后的处理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSession</span> *sessionWithoutADelegate = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultConfiguration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line">[[sessionWithoutADelegate dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Got response %@ with error %@.\n"</span>, response, error);</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"DATA:\n%@\nEND DATA\n"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line">&#125;] resume];</div></pre></td></tr></table></figure>
<p><strong>使用自定义的代理获取数据(data)</strong></p>
<p>如果你使用自定义的代理来retrieve data【取回或者检索数据】,代理必须实现至少以下方法：</p>
<ul>
<li><code>URLSession:dataTask:didReceiveData:</code> provides the data from a request to your task, one piece at a time</li>
<li><code>URLSession:task:didCompleteWithError:</code>indicates to your task that the data has been fully received.</li>
</ul>
<p>If your app needs to use the data after its <code>URLSession:dataTask:didReceiveData:</code> method returns, your code is responsible for storing the data in some way.For example, a web browser might need to render the data as it arrives along with any data it has previously received. To do this, it might use a dictionary that maps the task object to an NSMutableData object for storing the results, and then use the <code>appendData:</code> method on that object to append the newly received data.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString: <span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [defaultSession dataTaskWithURL:url];</div><div class="line"></div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<p><strong>下载文件</strong></p>
<p>下载文件，你应该实现以下代理方法：</p>
<ul>
<li><code>URLSession:downloadTask:didFinishDownloadingToURL:</code> provides your app with the URL to a temporary file where the downloaded content is stored.<strong>注意：在该方法返回之前，必须要做的是：要么打开文件读取内容，要么将文件移到一个永久的位置。因为当该方法返回时，如果该文件仍然存在那么该临时文件将会被删除</strong></li>
<li><code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> provides your app with status information about the progress of the download.</li>
<li><code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code> tells your app that its attempt to resume a previously failed download was successful.</li>
<li><code>URLSession:task:didCompleteWithError:</code> tells your app that the download failed.</li>
</ul>
<p>如果你将下载安排在background session，那么当你的APP不再运行了(译者注：即挂起状态)，下载仍然继续进行。如果下载安排在一个标准的或者ephemeral session，那么当你的APP重新运行时下载重新开始。(the download must begin anew when your app is relaunched.)</p>
<p>During the transfer from the server, if the user tells your app to pause the download, your app can cancel the task by calling the <code>cancelByProducingResumeData:</code> method. Later, your app can pass the returned resume data to either the <code>downloadTaskWithResumeData:</code> or <code>downloadTaskWithResumeData:completionHandler:</code> method to create a new download task that continues the download.</p>
<p>If the transfer fails, your delegate’s <code>URLSession:task:didCompleteWithError:</code> method is called with an <code>NSError</code> object. If the task is resumable, that object’s <code>userInfo</code> dictionary contains a value for the <code>NSURLSessionDownloadTaskResumeData</code> key; your app can pass the returned resume data to either the <code>downloadTaskWithResumeData:</code> or <code>downloadTaskWithResumeData:completionHandler:</code> method to create a new download task that retries the download.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/FoundationObjC.pdf"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [backgroundSession downloadTaskWithURL:url];</div><div class="line"></div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<p>下载任务的代理方法示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line"></div><div class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line"></div><div class="line">      didWriteData:(int64_t)bytesWritten</div><div class="line"></div><div class="line"> totalBytesWritten:(int64_t)totalBytesWritten</div><div class="line"></div><div class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Session %@ download task %@ wrote an additional %lld bytes (total %lld bytes) out of an expected %lld bytes.\n"</span>, session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line"></div><div class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line"></div><div class="line"> didResumeAtOffset:(int64_t)fileOffset</div><div class="line"></div><div class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Session %@ download task %@ resumed at offset %lld bytes out of an expected %lld bytes.\n"</span>, session, downloadTask, fileOffset, expectedTotalBytes);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line"></div><div class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line"></div><div class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Session %@ download task %@ finished downloading to URL %@\n"</span>, session, downloadTask, location);</div><div class="line"></div><div class="line"> </div><div class="line">    <span class="comment">// Perform the completion handler for the current session</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.completionHandlers[session.configuration.identifier]();</div><div class="line"></div><div class="line"> </div><div class="line">   <span class="comment">// Open the downloaded file for reading</span></div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> *readError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSFileHandle</span> *fileHandle = [<span class="built_in">NSFileHandle</span> fileHandleForReadingFromURL:location error:readError];</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">   <span class="comment">// Move the file to a new URL</span></div><div class="line"></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line"></div><div class="line">    <span class="built_in">NSURL</span> *cacheDirectory = [[fileManager URLsForDirectory:<span class="built_in">NSCachesDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>] firstObject];</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> *moveError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([fileManager moveItemAtURL:location toURL:cacheDirectory error:moveError]) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Uploading Body Content</strong></p>
<p>你的APP可以为HTTP POST请求提供请求体内容，方式有三种：1.作为一个<code>NSData</code>对象；2.作为一个文件；3.作为一个stream。一般而言，你的APP应该：</p>
<ul>
<li>Use an <code>NSData</code> object if your app already has the data in memory and has no reason to dispose of it.</li>
<li>Use a file if the content you are uploading exists as a file on disk, if you are doing background transfer, or if it is to your app’s benefit to write it to disk so that it can release the memory associated with that data.</li>
<li>Use a stream if you are receiving the data over a network.</li>
</ul>
<p>无论选择哪种方式，如果你的APP提供了自定义的session代理，那么，代理方法<code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code>应该被实现，该方法可以获得上传进度信息。</p>
<p>此外，如果使用stream作为请求体，必须提供一个自定义的代理，并实现代理方法<code>URLSession:task:needNewBodyStream:</code>，详细描述见下文<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW23" target="_blank" rel="external"> Uploading Body Content Using a Stream</a></p>
<p><strong>Uploading Body Content Using an NSData Object</strong></p>
<p>To upload body content with an <code>NSData</code> object, your app calls either the <code>uploadTaskWithRequest:fromData:</code> or <code>uploadTaskWithRequest:fromData:completionHandler:</code> method to create an upload task, and provides request body data through the <code>fromData</code> parameter.</p>
<p>The session object computes the <code>Content-Length</code> header based on the size of the data object.</p>
<p>你的APP必须提供任何服务器可能需要的额外的头信息—- content type （作为URL 请求对象的一部分）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *textFileURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/path/to/file.txt"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:textFileURL];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableURLRequest</span> *mutableRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</div><div class="line"></div><div class="line">mutableRequest.HTTPMethod = <span class="string">@"POST"</span>;</div><div class="line"></div><div class="line">[mutableRequest setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lld"</span>, data.length] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line"></div><div class="line">[mutableRequest setValue:<span class="string">@"text/plain"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromData:data];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p><strong>Uploading Body Content Using a File</strong></p>
<p>To upload body content from a file, your app calls either the <code>uploadTaskWithRequest:fromFile:</code> or <code>uploadTaskWithRequest:fromFile:completionHandler:</code> method to create an upload task, and provides a file URL from which the task reads the body content.</p>
<p>The session object computes the <code>Content-Length</code> header based on the size of the data object. If your app does not provide a value for the <code>Content-Type</code> header, the session also provides one.</p>
<p>Your app can provide any additional header information that the server might require as part of the URL request object</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *textFileURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/path/to/file.txt"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableURLRequest</span> *mutableRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</div><div class="line"></div><div class="line">mutableRequest.HTTPMethod = <span class="string">@"POST"</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromFile:textFileURL];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p><strong>Uploading Body Content Using a Stream</strong></p>
<p>To upload body content using a stream, your app calls the <code>uploadTaskWithStreamedRequest:</code> method to create an upload task. Your app provides a request object with an associated stream from which the task reads the body content.</p>
<p>Your app must provide any additional header information that the server might require—content type and length, for example—as part of the URL request object.</p>
<p>此外，因为session不能倒回提供的stream来重读数据，因此当session必须要重新尝试请求时(比如认证失败)，你必须提供一个新的stream。要这样做，需要实现代理方法<code>URLSession:task:needNewBodyStream:</code>。当该方法被调用时，你需要获取或者创建一个新的body stream，然后调用提供的的completion handler block with the new stream。<br><strong>注意：如果请求体是stream，则必须实现代理方法<code>URLSession:task:needNewBodyStream:</code>，因此必须自定义session的代理，不能使用系统提供的代理</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *textFileURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/path/to/file.txt"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableURLRequest</span> *mutableRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</div><div class="line"></div><div class="line">mutableRequest.HTTPMethod = <span class="string">@"POST"</span>;</div><div class="line"></div><div class="line">mutableRequest.HTTPBodyStream = [<span class="built_in">NSInputStream</span> inputStreamWithFileAtPath:textFileURL.path];</div><div class="line"></div><div class="line">[mutableRequest setValue:<span class="string">@"text/plain"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line"></div><div class="line">[mutableRequest setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lld"</span>, data.length] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [defaultSession uploadTaskWithStreamedRequest:mutableRequest];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<p><strong>Uploading a File Using a Download Task</strong></p>
<p>To upload body content for a download task, your app must provide either an <code>NSData</code> object or a body stream as part of the <code>NSURLRequest</code> object provided when it creates the download request.</p>
<p>If you provide the data using a stream, your app must provide a <code>URLSession:task:needNewBodyStream:</code> delegate method to provide a new body stream in the event of an authentication failure. 该方法描述见上文的 Uploading Body Content Using a Stream.</p>
<p>The download task behaves just like a data task except for the way in which the data is returned to your app.</p>
<p><strong>处理身份验证和自定义TLS链验证(Handling Authentication and Custom TLS Chain Validation)</strong></p>
<p>如果远程服务器返回状态码指示需要认证，而且authentication需要一个connection-level challenge(例如一个SSL client certificate【SSL 客户端证书】)，<code>NSURLSession</code>调用一个authentication challenge 代理方法。</p>
<ul>
<li>For session-level challenges—<code>NSURLAuthenticationMethodNTLM</code>, <code>NSURLAuthenticationMethodNegotiate</code>, <code>NSURLAuthenticationMethodClientCertificate</code>, or <code>NSURLAuthenticationMethodServerTrust</code>—the <code>NSURLSession</code> object calls the session delegate’s <code>URLSession:didReceiveChallenge:completionHandler:</code> method. If your app does not provide a session delegate method, the <code>NSURLSession</code> object calls the task delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code> method to handle the challenge.</li>
<li>For non-session-level challenges (all others), the <code>NSURLSession</code> object calls the task delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code> method to handle the challenge. If your app provides a session delegate and you need to handle authentication, then you must either handle the authentication at the task level or provide a task-level handler that calls the per-session handler explicitly. The session delegate’s <code>URLSession:didReceiveChallenge:completionHandler:</code> method is not called for non-session-level challenges.（非session层怎么处理没看懂啊啊啊？？？？）</li>
</ul>
<p><strong>注意：</strong>Kerberos authentication is handled transparently.</p>
<p>When authentication fails for a task that has a stream-based upload body, the task cannot necessarily rewind and reuse that stream safely. Instead, the <code>NSURLSession</code> object calls the delegate’s <code>URLSession:task:needNewBodyStream:</code>delegate method to obtain a new <code>NSInputStream</code> object that provides the body data for the new request. (The session object does not make this call if the task’s upload body is provided from a file or an <code>NSData</code> object.)</p>
<p><strong>处理iOS后台活动(Handling iOS Background Activity)</strong></p>
<p>相关的说明见上文<strong>有关后台传输的考虑(background transfer considerations)</strong></p>
<p>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.example.com/"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *backgroundDownloadTask = [backgroundSession downloadTaskWithURL:url];</div><div class="line"></div><div class="line">[backgroundDownloadTask resume];</div><div class="line"><span class="comment">//Session delegate methods for iOS background downloads</span></div><div class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</div><div class="line"></div><div class="line">    AppDelegate *appDelegate = (AppDelegate *)[[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (appDelegate.backgroundSessionCompletionHandler) &#123;</div><div class="line"></div><div class="line">        CompletionHandler completionHandler = appDelegate.backgroundSessionCompletionHandler;</div><div class="line"></div><div class="line">        appDelegate.backgroundSessionCompletionHandler = <span class="literal">nil</span>;</div><div class="line">        completionHandler();</div><div class="line">   &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"All tasks are finished"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//App delegate methods for iOS background downloads</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) CompletionHandler backgroundSessionCompletionHandler;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line"></div><div class="line">handleEventsForBackgroundURLSession:(<span class="built_in">NSString</span> *)identifier</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)())completionHandler</div><div class="line">&#123;</div><div class="line">   <span class="keyword">self</span>.backgroundSessionCompletionHandler = completionHandler;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p><strong>编码URL数据(Encoding URL Data)</strong></p>
<p>在 iOS 程序访问 HTTP 资源时需要对 URL 进行 Encode，比如像拼出来的 <a href="http://unmi.cc?p1=%+&amp;sd" target="_blank" rel="external">http://unmi.cc?p1=%+&amp;sd</a> f&amp;p2=中文，其中的中文、特殊符号&amp;％和空格都必须进行转译才能正确访问。</p>
<p>要对字符串进行URL编码，使用Core Foundation函数<code>CFURLCreateStringByAddingPercentEscapes</code>和<code>CFURLCreateStringByReplacingPercentEscapesUsingEncoding</code>.这些函数允许你指定一些列字符来进行编码，除了high-ASCII (0x80–0xff) and nonprintable characters.</p>
<blockquote>
<p>ASCII defines code numbers for 128 character, which are the alphabetic and numeric character on a keyboard and some additional character such a punctuation mark.High ASCII includes additional ASCII characters up to 256, which may include foreign language accents, math symbols, trademark and copyright symbols, etc.These character are not the same on all computer.</p>
</blockquote>
<p>根据<a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="external">RFC 3986</a>，在URL中的保留字符是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">reserved    = gen-delims / sub-delims</div><div class="line">gen-delims  = <span class="string">":"</span> / <span class="string">"/"</span> / <span class="string">"?"</span> / <span class="string">"#"</span> / <span class="string">"["</span> / <span class="string">"]"</span> / <span class="string">"@"</span></div><div class="line">sub-delims  = <span class="string">"!"</span> / <span class="string">"$"</span> / <span class="string">"&amp;"</span> / <span class="string">"'"</span> / <span class="string">"("</span> / <span class="string">")"</span></div><div class="line">            / <span class="string">"*"</span> / <span class="string">"+"</span> / <span class="string">","</span> / <span class="string">";"</span> / <span class="string">"="</span></div></pre></td></tr></table></figure>
<p>正确地URL编码一个包含在URL中UTF-8字符串，操作如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意CFURLCreateStringByAddingPercentEscapes方法已经被废弃，改用NSString类的实例方法</span></div><div class="line"><span class="comment">//[aString stringByAddingPercentEncodingWithAllowedCharacters:]</span></div><div class="line"><span class="built_in">CFStringRef</span> originalString = ...</div><div class="line"></div><div class="line"><span class="built_in">CFStringRef</span> encodedString = <span class="built_in">CFURLCreateStringByAddingPercentEscapes</span>(</div><div class="line"></div><div class="line">    kCFAllocatorDefault,</div><div class="line"></div><div class="line">    originalString,</div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,</div><div class="line"></div><div class="line">    <span class="built_in">CFSTR</span>(<span class="string">":/?#[]@!$&amp;'()*+,;="</span>),</div><div class="line"></div><div class="line">    kCFStringEncodingUTF8);</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *originalString = <span class="string">@"http://www.baidu.com/$*#我开飞机上的了%dskfl%----____&amp;;;&amp;fdf;"</span>;</div><div class="line"><span class="comment">//编码</span></div><div class="line"><span class="built_in">NSString</span> *encodedString = [originalString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLPathAllowedCharacterSet]];</div><div class="line"><span class="comment">//http://www.baidu.com/$*%23%E6%88%91%E5%BC%80%E9%A3%9E%E6%9C%BA%E4%B8%8A%E7%9A%84%E4%BA%86%25dskfl%25----____&amp;;;&amp;fdf;</span></div><div class="line"><span class="comment">//解码</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,encodedString.stringByRemovingPercentEncoding);</div><div class="line"><span class="comment">//http://www.baidu.com/$*#我开飞机上的了%dskfl%----____&amp;;;&amp;fdf;</span></div></pre></td></tr></table></figure>
<p><strong>处理重定向和其他请求变化(Handling Redirects and Other Request Changes)</strong></p>
<p>当服务器响应请求，指示客户端应该使用另一个URL发起一个新的请求，即为重定向。重定向发生时<code>NSURLSession</code>类会通知他的代理。</p>
<p>代理必须实现方法<code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code>方法。</p>
<p>在该方法中代理可以检查由重定向引起的新的请求和响应，通过<code>NSURLSession</code>的completion handler返回一个新的request。</p>
<p>代理可以做以下任何事情：</p>
<ul>
<li>Allow the redirect by simply returning the provided request.</li>
<li>Create a new request, pointing to a different URL, and return that request.</li>
<li>Reject the redirect and receive any existing data from the connection by returning <code>nil</code>.</li>
</ul>
<p>此外，代理可以取消重定向和connection。with <code>NSURLSession</code>，代理可以向task object发送<code>cancel</code>消息。</p>
<p>The delegate also receives the <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> message if the <code>NSURLProtocol</code>（注：<code>NSURLProtocol</code>是抽象基类） subclass that handles the request has changed the <code>NSURLRequest</code> in order to standardize its format, for example, changing a request for <code>http://www.apple.com</code> to <code>http://www.apple.com/.</code> This occurs because the standardized(标准化), or canonical(规范化), version of the request is used for cache management. In this special case, the response passed to the delegate is nil and the delegate should simply return the provided request.</p>
<p>If the delegate doesn’t provide an implementation for an appropriate redirect handling delegate method, all canonical changes and server redirects are allowed.</p>
<p>示例代码：允许canonical changes and denies all server redirects</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line"></div><div class="line">        task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line"></div><div class="line">        willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)redirectResponse</div><div class="line"></div><div class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line"></div><div class="line">        completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSURLRequest</span> *newRequest = request;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (redirectResponse) &#123;</div><div class="line"></div><div class="line">        newRequest = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    completionHandler(newRequest);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Authentication Challenges and TLS Chain Validation</strong></p>
<p><code>NSURLRequest</code>对象经常遇到来自它正连接的服务器的authentication challenge或者credentials请求。当request遇到authentication challenge时，<code>NSURLSession</code>类的代理会受到通知。</p>
<p><strong>Important:</strong> <strong>The URL loading system classes do not call their delegates to handle request challenges unless the server response contains a <code>WWW-Authenticate</code> header. Other authentication types, such as proxy authentication and TLS trust validation do not require this header.</strong></p>
<p><strong>决定如何响应一个authentication challenge</strong></p>
<p>If a session task requires authentication, and there are no valid credentials available, either as part of the requested URL or in the shared <code>NSURLCredentialStorage</code>, it creates an authentication challenge. It first sends <code>URLSession:task:didReceiveChallenge:completionHandler:</code> to its task delegate to handle the authentication challenge. If the task delegate does not respond to that message, the task sends <code>URLSession:task:didReceiveChallenge:completionHandler:</code> to its session delegate to handle the authentication challenge.</p>
<p>要是连接能够继续进行，而不会因为authentication的问题而断开，代理有三种选择：</p>
<ul>
<li>提供authentication credentials</li>
<li>尝试继续连接without credentials</li>
<li>取消authentication challenge</li>
</ul>
<p>要确定采取哪种策略，传递给方法的<code>NSURLAuthenticationChallenge</code>实例包含以下信息：什么触发了authentication challenge，对challenge做了多少次尝试，任何之前尝试的credentials，需要credentials的<code>NSURLProtectionSpace</code>，challenge的发送者。</p>
<p>如果authentication challenge之前已经尝试authenticate并且失败了(比如，用户更改了存在服务器上的密码)，你可以通过在authentication challenge上调用<code>proposedCredential</code>来获得已经尝试的credentials。The delegate can then use these credentials to populate a dialog（populate a dialog ：填充对话框） that it presents to the user.</p>
<p>调用authentication challenge的<code>previousFailureCount</code>返回之前authentication尝试的总数，该总数也包含来自其他的authentication protocol的尝试。The delegate can provide this information to the user, to determine whether the credentials it supplied previously are failing, or to limit the maximum number of authentication attempts.</p>
<p><strong>对authentication challenge的响应</strong></p>
<p>以下是对代理方法<code>URLSession:didReceiveChallenge:completionHandler:</code> or <code>URLSession:task:didReceiveChallenge:completionHandler:</code>的三种响应方式：</p>
<p><strong>提供credentials</strong></p>
<p>要尝试authenticate，应用程序需要使用按服务器要求的形式的认证信息创建一个<code>NSURLCredential</code>对象。通过在authentication  challenge的protection space上调用<code>authenticationMethod</code>方法来获得服务器的authentication方式。以下是<code>NSURLCredential</code>支持的一些authentication方式：</p>
<ul>
<li>HTTP basic authentication (<code>NSURLAuthenticationMethodHTTPBasic</code>) requires a user name and password. Prompt the user for the necessary information and create an <code>NSURLCredential</code> object with <code>credentialWithUser:password:persistence:</code>.</li>
<li>HTTP digest authentication (<code>NSURLAuthenticationMethodHTTPDigest</code>), like basic authentication, requires a user name and password. (The digest is generated automatically.) Prompt the user for the necessary information and create an <code>NSURLCredential</code> object with <code>credentialWithUser:password:persistence:</code>.</li>
<li>Client certificate authentication (<code>NSURLAuthenticationMethodClientCertificate</code>) requires the system identity and all certificates needed to authenticate with the server. Create an <code>NSURLCredential</code> object with <code>credentialWithIdentity:certificates:persistence:</code>.</li>
<li>Server trust authentication (<code>NSURLAuthenticationMethodServerTrust</code>) requires a trust provided by the protection space of the authentication challenge. Create an <code>NSURLCredential</code> object with <code>credentialForTrust:</code>.</li>
</ul>
<p>创建了<code>NSURLCredential</code>对象后，使用提供的completion handler block将该对象传递给authentication challenge的sender。</p>
<p><strong>continuing without credentials</strong></p>
<p>如果代理选择不为authentication challenge提供一个credential，可以尝试继续进行。为completion handler block传递下列值之一：</p>
<ul>
<li><code>NSURLSessionAuthChallengePerformDefaultHandling</code> processes the request <em>as though</em>（好像，仿佛） the delegate did not provide a delegate method to handle the challenge.</li>
<li><code>NSURLSessionAuthChallengeRejectProtectionSpace</code> rejects the challenge. Depending on the authentication types allowed by the server’s response, the URL loading class may call this delegate method more than once, for additional protection spaces.</li>
</ul>
<p><strong>取消连接</strong></p>
<p>代理也可以通过向提供的completion handler block传递<code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code>来取消authentication challenge。</p>
<p>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line"></div><div class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</div><div class="line"></div><div class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> * __<span class="keyword">nullable</span> credential))completionHandler</div><div class="line"></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span> ([challenge previousFailureCount] == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">NSURLCredential</span> *newCredential = [<span class="built_in">NSURLCredential</span> credentialWithUser:[<span class="keyword">self</span> preferencesName]</div><div class="line">                                                                   password:[<span class="keyword">self</span> preferencesPassword]</div><div class="line">                                                                persistence:<span class="built_in">NSURLCredentialPersistenceNone</span>];</div><div class="line">       completionHandler(<span class="built_in">NSURLSessionAuthChallengeUseCredential</span>, newCredential);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// Inform the user that the user name and password are incorrect</span></div><div class="line"></div><div class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>, <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>If the authentication challenges goes unhandled by the session or task delegate, and credentials are not available or if they fail to authenticate, a <code>continueWithoutCredentialForAuthenticationChallenge:</code> message is sent by the underlying implementation.</strong></p>
<p><strong>Performing Custom TLS Chain Validation(执行自定义的TLS链验证)</strong></p>
<p>In the NSURL family of APIs, TLS chain validation is handled by your app’s authentication delegate method, but instead of providing credentials to authenticate the user (or your app) to the server, your app instead checks the credentials that the server provides during the TLS handshake, then tells the URL loading system whether it should accept or reject those credentials.</p>
<p>If you need to perform chain validation in a nonstandard way (such as accepting a specific self-signed certificate for testing), your app must implement either the <code>URLSession:didReceiveChallenge:completionHandler:</code> or <code>URLSession:task:didReceiveChallenge:completionHandler:</code> delegate method. If you implement both, the session-level method is responsible for handling the authentication.</p>
<p>Within your authentication handler delegate method, you should check to see if the challenge protection space has an authentication type of <code>NSURLAuthenticationMethodServerTrust</code>, and if so, obtain the <code>serverTrust</code> information from that protection space.</p>
<p><strong>理解缓存访问</strong></p>
<p>URL loading system提供了一个在磁盘上和内存中缓存的组合，来缓存对请求的响应。缓存降低了应用程序对网络的依赖，提高了性能。</p>
<p><strong>对request使用缓存</strong></p>
<p>An <code>NSURLRequest</code> instance specifies how the local cache is used by setting the cache <em>policy(政策，策略)</em> to one of the <code>NSURLRequestCachePolicy</code> values: <code>NSURLRequestUseProtocolCachePolicy</code>, <code>NSURLRequestReloadIgnoringCacheData</code>, <code>NSURLRequestReturnCacheDataElseLoad</code>, or <code>NSURLRequestReturnCacheDataDontLoad</code>.</p>
<p>默认缓存策略是<code>NSURLRequestUseProtocolCachePolicy</code>。The <code>NSURLRequestUseProtocolCachePolicy</code> behavior is protocol specific and is defined as being the best conforming policy for the protocol.</p>
<p><code>NSURLRequestReloadIgnoringCacheData</code>：从原始来源加载数据，完全忽略缓存。</p>
<p><code>NSURLRequestReturnCacheDataElseLoad</code>：使得URL loading system使用用缓存数据，忽略缓存是否过期，只有当没有缓存的版本时(即没有缓存时)才从原始来源加载数据。</p>
<p><code>NSURLRequestReturnCacheDataDontLoad</code>：只有缓存数据被返回。如果响应不是在本地缓存，尝试使用该缓存策略创建一个<code>NSURLSessionTask</code>实例会立即返回<code>nil</code>。这跟离线模式相似，从来不会发起一个网络连接。</p>
<p><strong>Note: Currently, only responses to HTTP and HTTPS requests are cached. The FTP and <code>file</code> protocols attempt to access the originating source as allowed by the cache policy. Custom <code>NSURLProtocol</code> classes can optionally provide caching.</strong></p>
<p><strong>Cache Use Semantics(语义) for the HTTP Protocol</strong></p>
<p>The most complicated cache use situation is when a request uses the HTTP protocol and has set the cache policy to <code>NSURLRequestUseProtocolCachePolicy</code>.</p>
<p>If an <code>NSCachedURLResponse</code> does not exist for the request, then the URL loading system fetches the data from the originating source.</p>
<p>If a cached response exists for the request, the URL loading system checks the response to determine if it specifies that the contents must be revalidated.</p>
<p>If the contents must be revalidated, the URL loading system makes a HEAD request to the originating source to see if the resource has changed. If it has not changed, then the URL loading system returns the cached response. If it has changed, the URL loading system fetches the data from the originating source.</p>
<p>If the cached response doesn’t specify that the contents must be revalidated, the URL loading system examines the maximum age or expiration specified in the cached response. If the cached response is recent enough, then the URL loading system returns the cached response. If the response is stale, the URL loading system makes a HEAD request to the originating source to determine whether the resource has changed. If so, the URL loading system fetches the resource from the originating source. Otherwise, it returned the cached response.</p>
<p>RFC 2616, Section 13 (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13" target="_blank" rel="external">http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13</a>) specifies the semantics involved in detail.</p>
<p><strong>以编程方式控制缓存(Controlling Caching Programmatically)</strong></p>
<p>默认情况下，请求的数据基于request的缓存策略被缓存，, as interpreted by the <code>NSURLProtocol</code> subclass that handles the request.</p>
<p>如果protocol支持缓存且需要对缓存做更精准的控制，可以实现代理方法，该方法中你可以决定每次请求是否被缓存。</p>
<p>For <code>NSURLSession</code> data and upload tasks, implement the <code>URLSession:dataTask:willCacheResponse:completionHandler:</code> method. This delegate method is called only for data and upload tasks. The caching policy for download tasks is determined by the specified cache policy exclusively.</p>
<p>对于<code>NSURLSession</code>，你的代理方法调用completion handler block来告诉session什么需要缓存。代理一般提供下列值之一：</p>
<ul>
<li>The provided response object to allow caching</li>
<li>A newly created response object to cache a modified response—for example, a response with a storage policy that allows caching to memory but not to disk</li>
<li><code>nil</code> to prevent caching</li>
</ul>
<p>你的代理方法可以可以插入对象到<code>userInfo</code>字典当中，该字典与<code>NSCacheURLResponse</code>对象相关联，这会引起那些被插入的对象储存到缓存中作为response的一部分。</p>
<p><strong>注意：你的代理方法必须总是要调用方法提供的completion handler，否则将会内存泄漏</strong></p>
<p>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//prevents the on-disk caching of HTTPS responses. It also adds the current date to the user info dictionary for responses that are cached.</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line"></div><div class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</div><div class="line"></div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> * __<span class="keyword">nullable</span> cachedResponse))completionHandler &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSCachedURLResponse</span> *newCachedResponse = proposedResponse;</div><div class="line"></div><div class="line">    <span class="built_in">NSDictionary</span> *newUserInfo;</div><div class="line"></div><div class="line">    newUserInfo = [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSDate</span> date]</div><div class="line"></div><div class="line">                                              forKey:<span class="string">@"Cached Date"</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([proposedResponse.response.URL.scheme isEqualToString:<span class="string">@"https"</span>]) &#123;</div><div class="line"></div><div class="line"><span class="meta">#if ALLOW_IN_MEMORY_CACHING</span></div><div class="line"></div><div class="line">        newCachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc]</div><div class="line"></div><div class="line">                             initWithResponse:proposedResponse.response</div><div class="line"></div><div class="line">                             data:proposedResponse.data</div><div class="line"></div><div class="line">                             userInfo:newUserInfo</div><div class="line"></div><div class="line">                             storagePolicy:<span class="built_in">NSURLCacheStorageAllowedInMemoryOnly</span>];</div><div class="line"></div><div class="line"><span class="meta">#else // !ALLOW_IN_MEMORY_CACHING</span></div><div class="line"></div><div class="line">        newCachedResponse = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="meta">#endif // ALLOW_IN_MEMORY_CACHING</span></div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        newCachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc]</div><div class="line"></div><div class="line">                             initWithResponse:[proposedResponse response]</div><div class="line"></div><div class="line">                             data:[proposedResponse data]</div><div class="line"></div><div class="line">                             userInfo:newUserInfo</div><div class="line"></div><div class="line">                             storagePolicy:[proposedResponse storagePolicy]];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    completionHandler(newCachedResponse);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Cookies and Custom Protocols</strong></p>
<p>如果自己管理cookies,如添加和删除cookies或者决定哪些cookies应该被接受：<br><strong>Cookies Storage</strong></p>
<p>由于HTTP协议的无状态特性，客户端经常使用cookies作为通过URL请求得到的数据的持久化存储。URL loading system 提供接口来创建和管理cookies，将cookies作为HTTP请求的一部分发送cookies，当解释web服务器的响应时接收cookies。</p>
<p><code>NSHTTPCookie</code>类封装了一个cookie，为许多常见的cookie属性提供存取方法。This class also provides methods to convert HTTP cookie headers to <code>NSHTTPCookie</code> instances and convert an <code>NSHTTPCookie</code> instance to headers suitable(合适的) for use with an <code>NSURLRequest</code> object. The URL loading system automatically sends any stored cookies <em>appropriate(适当的，合适的)</em> for an <code>NSURLRequest</code> object unless the request specifies not to send cookies. <em>Likewise(同样地)</em>, cookies returned in an <code>NSURLResponse</code> object are accepted in accordance with the current cookie acceptance policy.</p>
<p><code>NSHTTPCookieStorage</code>类提供接口管理<code>NSHTTPCookie</code>对象的集合，这些<code>NSHTTPCookie</code>对象被所有的APP共享。</p>
<p><strong>注意：</strong>在iOS中cookies是不能在APP间共享的。</p>
<p>使用<code>NSHTTPCookieStorage</code>指定cookie接受策略(acceptance policy).cookie接受策略控制是否cookies应该总是被接受看，或从不被接受，或者be accepted only from the same domain as the main document URL.</p>
<p><strong>注意：</strong>在一个APP中更改cookie接受策略会影响所有其他正在运行的APP的cookie接受策略。</p>
<p>When another app changes the cookie storage or the cookie acceptance policy, <code>NSHTTPCookieStorage</code> notifies an app by posting the <code>NSHTTPCookieManagerCookiesChangedNotification</code> and <code>NSHTTPCookieStorageAcceptPolicyChangedNotification</code> notifications.</p>
<p><strong>自定义协议(Protocol Support)</strong></p>
<p>如果你的APP需要支持一种基于URL的协议而<code>NSURL</code>原生不支持，你可以注册自己的自定义协议类来提供必要的支持。</p>
<p>URL loading system原生支持五种协议：<code>http,https,ftp,data,file</code>。要实现自定义，继承<code>NSURLProtocol</code>，然后使用<code>NSURLProtocol</code>类方法<code>registerClass:</code>向URL loading system注册新类。当<code>NSURLSession</code>对象为<code>NSURLRequest</code>对象发起一个connection，URL loading system按注册的类的注册顺序逆序询问每一个注册的类。第一个对消息<code>canInitWithRequest:</code>返回<code>YES</code>的类，被用于处理该请求。</p>
<p>如果自定义的协议为它的请求或者响应而需要额外的属性，你可以为<code>NSURLRequest</code>, <code>NSMutableURLRequest</code>, and <code>NSURLResponse</code>类创建类别，为那些属性提供存取方法。The <code>NSURLProtocol</code> class provides methods for setting and getting property values in those accessors.</p>
<p>当连接开始和完成时，URL loading system负责创建和释放<code>NSURLProtocol</code>实例。你的APP从来都不应该直接创建<code>NSURLProtocol</code>实例。</p>
<p>当<code>NSURLProtocol</code>子类被URL loading system初始化，并提供了该子类一个遵循<code>NSURLProtocolClient</code>协议的客户端对象(client object)。该<code>NSURLProtocol</code>子类当他创建response，接受数据，重定向到新的URL，请求authentication，完成加载时，发送消息的路径是：从<code>NSURLProtocolClient</code>协议到client object到通知URL loading system。如果自定义协议支持authentication，那么它必须遵循<code>NSURLAuthenticationChallengeSender</code>协议。</p>
<p><strong>URL Session的生命周期(Life Cycle of a URL Session)</strong></p>
<p>在以下情况下必须使用自己的代理不能使用系统提供的代理：</p>
<ul>
<li>Uses background sessions to download or upload content while your app is not running.</li>
<li>Performs custom authentication.</li>
<li>Performs custom SSL certificate verification.</li>
<li>Decides whether a transfer should be downloaded to disk or displayed based on the MIME type returned by the server or other similar <em>criteria(标准，准则)</em>.</li>
<li>Uploads data from a body stream (as opposed to an <code>NSData</code> object).</li>
<li>Limits caching programmatically.</li>
<li>Limits HTTP redirects programmatically.</li>
</ul>
<p><strong>Life Cycle of a URL Session with System-Provided Delegates</strong></p>
<ol>
<li>创建一个session configuration。对于background sessions，configuration 必须包含一个独一无二的identifer.Store that identifier, and use it to reassociate with the session if your app crashes or is terminated or suspended.</li>
<li>Create a session, specifying a configuration object and a <code>nil</code> delegate.</li>
<li><p>Create task objects within a session that each represent a resource request.每一个task都是从一个暂停状态开始的(Each task starts out in a suspended state.这也是为什么开始任务时都调用resume)。After your app calls <code>resume</code> on the task, it begins downloading the specified resource.</p>
<p>The task objects are subclasses of <code>NSURLSessionTask</code>—<code>NSURLSessionDataTask</code>, <code>NSURLSessionUploadTask</code>, or <code>NSURLSessionDownloadTask</code>, depending on the behavior you are trying to achieve.(当然，一般APP中会有不止一个task添加到一个session，在此以一个task介绍)</p>
<p><strong>重要：</strong>如果你使用<code>NSURLSession</code>类，没有提供代理，即使用了系统提供的代理，那么你在创建task时，必须使用带有<code>completionHandler</code>回调参数的方法，否则你将得不到数据。</p>
</li>
<li><p>For a download task, during the transfer from the server, if the user tells your app to pause the download, cancel the task by calling <code>cancelByProducingResumeData:</code> method. Later, pass the returned resume data to either the <code>downloadTaskWithResumeData:</code> or <code>downloadTaskWithResumeData:completionHandler:</code> method to create a new download task that continues the download.</p>
</li>
<li><p>当task完成时，<code>NSURLSession</code>对象调用task的completion handler。</p>
<p><strong>注意：</strong><code>NSURLSession</code> does not report server errors through the error parameter. The only errors your app receives through the error parameter are client-side errors, such as being unable to resolve the hostname or connect to the host. The error codes are described in <code>URL Loading System Error Codes</code>.</p>
<p>Server-side errors are reported through the HTTP status code in the <code>NSHTTPURLResponse</code> object.</p>
</li>
<li><p>When your app no longer needs a session, invalidate it by calling either <code>invalidateAndCancel</code> (to cancel outstanding tasks) or <code>finishTasksAndInvalidate</code> (to allow outstanding tasks to finish before invalidating the object).</p>
</li>
</ol>
<p><strong>Life Cycle of a URL Session with Custom Delegates</strong></p>
<p>Delegates are required for all background downloads and uploads. These delegates must provide all of the delegate methods in the <code>NSURLSessionDownloadDelegate</code> protocol.</p>
<p>Data task delegates receive both an initial call, in <strong>which you can convert the request into a download（即可以将data task 转换为 download task）</strong>, and subsequent calls, which provide pieces of data as they arrive from the remote server.</p>
<p>需要background  task时必须使用自定义代理。</p>
<p>以下是当使用自定义代理时，你的APP必须做的一系列基本的方法调用：</p>
<ol>
<li>Create a session configuration. For background sessions, this configuration must contain a unique identifier. Store that identifier, and use it to reassociate with the session if your app crashes or is terminated or suspended.</li>
<li>Create a session, specifying a configuration object and, optionally, a delegate.</li>
<li><p>Create task objects within a session that each represent a resource request.</p>
<p>Each task starts out in a suspended state. After your app calls <code>resume</code> on the task, it begins downloading the specified resource.</p>
<p>The task objects are subclasses of <code>NSURLSessionTask</code>—<code>NSURLSessionDataTask</code>, <code>NSURLSessionUploadTask</code>, or <code>NSURLSessionDownloadTask</code>, depending on the behavior you are trying to achieve.(当然，一般APP中会有不止一个task添加到一个session，在此以一个task介绍)</p>
</li>
<li><p>If the remote server returns a status code that indicates authentication is required and if that authentication requires a connection-level challenge (such as an SSL client certificate), <code>NSURLSession</code> calls an authentication challenge delegate method.</p>
</li>
</ol>
<ul>
<li>For session-level challenges—<code>NSURLAuthenticationMethodNTLM</code>, <code>NSURLAuthenticationMethodNegotiate</code>, <code>NSURLAuthenticationMethodClientCertificate</code>, or <code>NSURLAuthenticationMethodServerTrust</code>—the <code>NSURLSession</code> object calls the session delegate’s <code>URLSession:didReceiveChallenge:completionHandler:</code>method. If your app does not provide a session delegate method, the <code>NSURLSession</code> object calls the task delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code>method to handle the challenge.</li>
<li>For non-session-level challenges (all others), the <code>NSURLSession</code> object calls the session delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code> method to handle the challenge. If your app provides a session delegate and you need to handle authentication, then you must either handle the authentication at the task level or provide a task-level handler that calls the per-session handler explicitly. The session delegate’s <code>URLSession:didReceiveChallenge:completionHandler:</code>method is <strong>not</strong> called for non-session-level challenges.</li>
<li>If authentication fails for an upload task, if the task’s data is provided from a stream, the <code>NSURLSession</code> object calls the delegate’s <code>URLSession:task:needNewBodyStream:</code> delegate method. The delegate must then provide a new <code>NSInputStream</code> object to provide the body data for the new request.</li>
</ul>
<p>\5. Upon receiving an HTTP redirect response, the <code>NSURLSession</code> object calls the delegate’s <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> method. That delegate method calls the provided completion handler with either the provided <code>NSURLRequest</code> object (to follow the redirect), a new <code>NSURLRequest</code> object (to redirect to a different URL), or <code>nil</code> (to treat the redirect’s response body as a valid response and return it as the result).</p>
<ul>
<li>If the redirect is followed, go back to step 4 (authentication challenge handling).</li>
<li>If the delegate does not implement this method, <strong>the redirect is followed up to the maximum number of redirects.</strong>（个人理解，应该是继续尝试连接，直到达到重定向连接次数限制为止）</li>
</ul>
<p>\6. For a (re-)download task created by calling <code>downloadTaskWithResumeData:</code> or <code>downloadTaskWithResumeData:completionHandler:</code>, <code>NSURLSession</code> calls the delegate’s <code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code> method with the new task object.</p>
<p>\7. For a data task, the <code>NSURLSession</code> object calls the delegate’s <code>URLSession:dataTask:didReceiveResponse:completionHandler:</code> method. <strong>Decide whether to convert the data task into a download task, and then call the completion callback to continue receiving data or downloading data.</strong></p>
<p>If your app chooses to convert the data task to a download task, NSURLSession calls the delegate’s <code>URLSession:dataTask:didBecomeDownloadTask:</code> method with the new download task as a parameter. <em>After this call, the delegate receives no further callbacks from the data task, and begins receiving callbacks from the download task.</em></p>
<p>\8. 如果task由<code>uploadTaskWithStreamedRequest:</code>创建，<code>NSURLSession</code>调用代理方法<code>URLSession:task:needNewBodyStream:</code>来提供body data.</p>
<p>\9. During the initial upload of body content to the server (if applicable), the delegate periodically receives <code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code> callbacks that report the progress of the upload.</p>
<p>\10. 在从服务器传输数据期间，task delegate周期性的收到回调，用来报告传输进度。对于download task，session调用代理方法<code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code>,该方法带有已成功写入磁盘的字节数。对于data task，session调用代理方法<code>URLSession:dataTask:didReceiveData:</code>,该方法带有接收到的实际的数据块。</p>
<p>  对于download task，在从服务器传输数据期间，如果用户暂停了下载，那么通过调用方法<code>cancelByProducingResumeData:</code>来取消task。</p>
<p>  之后，如果用户要求重新继续下载，传递返回的resume data到方法<code>downloadTaskWithResumeData:</code>或者<code>downloadTaskWithResumeData:completionHandler:</code>来创建一个新的download task，将会继续下载任务，然后跳到第3步(creating and resuming task objects)。</p>
<p>\11. 对于data task,<code>NSURLSession</code>对象调用代理方法<code>URLSession:dataTask:willCacheResponse:completionHandler:</code>.你的APP应该决定是否允许缓存。如果你不实现该方法，默认行为是使用session的configuration对象指定的缓存策略。</p>
<p>\12. 如果一个download task成功完成，<code>NSURLSession</code>调用方法<code>URLSession:downloadTask:didFinishDownloadingToURL:</code>，该方法带有一个临时文件的位置。在该代理方法返回之前你的APP必须要么读取来自该临时文件的数据，要么移动该文件到你的APP沙盒容器目录中的一个能持久存储的位置。</p>
<p>\13. 当任何的task完成时，<code>NSURLSession</code>调用代理方法<code>URLSession:task:didCompleteWithError:</code>，该方法带有一个error，如果出现错误error有值，如果任务成功完成error值为<code>nil</code>。</p>
<p>如果任务失败，大部分APP应该重新尝试请求，直到用户取消下载或者服务器返回error指示了该请求从来不会成功。然而，你的APP不应该立即尝试重试(retry）。相反的，应该使用reachability apis 来确定是否服务器是可访问的，然后只有当收到reachability已经发生改变的通知时，进行一个新的request。【<strong>注：Upload and download tasks in background sessions are automatically retried 不需要reachability API</strong>】</p>
<p>如果download task能够被resume，<code>NSError</code>对象的<code>userInfo</code>字典包含a value for the <code>NSURLSessionDownloadTaskResumeData</code> key.你的APP应该调用<code>downloadTaskWithResumeData:</code>或者<code>downloadTaskWithResumeData:completionHandler:</code>并传递该值作为参数，用来创建一个新的download task继续已经存在的下载(continue the existing download).</p>
<p>如果download task不能被resume，你的APP应该创建一个新的download task，从开始重新启动事务（即从头开始下载）。</p>
<p>在任何情况下，如果因任何原因(除了服务器错误)导致传输失败，跳到第3步(creating and resuming task objects).</p>
<p><strong>注意：</strong><code>NSURLSession</code>不会通过error参数报告服务器错误。你的代理通过error参数收到的错误只是客户端这边的错误，例如无法解析主机名或连接到主机。The error codes are described in <code>URL Loading System Error Codes</code>.</p>
<p>服务器的错误通过<code>NSHTTPURLResponse</code>对象中HTTP status code报告。</p>
<p>\14. If the response is <em>multipart encoded（多重编码）</em>, the session may call the delegate’s <code>didReceiveResponse</code> method again, followed by zero or more additional <code>didReceiveData</code> calls. If this happens, go to step 7 (handling the didReceiveResponse call).</p>
<p>\15. 当你不再需要一个session时，调用<code>invalidateAndCancel</code>（取消未完成的任务）或者<code>finishTaskAndInvalidate</code>(允许在使对象无效前让未完成的任务完成)使session作废。</p>
<p>在作废session后，当所有的未完成的任务已经被取消或者已经结束，session会调用代理方法<code>URLSession:didBecomeInvalidWithError:</code>。当该代理方法返回时，session会处理对代理对象的强引用。</p>
<p><strong>注意：session对象对代理保持强引用直到你的APP明确将session作废(invalidate the session)。如果你不使session无效，你的APP会内存泄漏。</strong></p>
<p>如果你的APP取消了一个正在进行中的下载，<code>NSURLSession</code>对象会调用<code>URLSession:task:didCompleteWithError:</code><em>as though（好像，仿佛）</em>an error occurred.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/15/CALayer上动画的暂停和恢复/" rel="next" title="CALayer上动画的暂停和恢复">
                <i class="fa fa-chevron-left"></i> CALayer上动画的暂停和恢复
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description">一个奋斗中的程序猿</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
